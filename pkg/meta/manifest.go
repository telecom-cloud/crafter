package meta

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	gv "github.com/hashicorp/go-version"
	"gopkg.in/yaml.v3"
)

const ManifestFile = ".cft"

type Manifest struct {
	Version  string `yaml:"cftVersion"`
	ModelDir string `yaml:"modelDir"`
}

var GoVersion *gv.Version

func init() {
	// valid by unit test already, so no need to check error
	GoVersion, _ = gv.NewVersion(Version)
}

func (manifest *Manifest) InitAndValidate(dir string) error {
	m, err := loadConfigFile(filepath.Join(dir, ManifestFile))
	if err != nil {
		return fmt.Errorf("can not load \".cft\", err: %v", err)
	}

	if len(m.Version) == 0 {
		return fmt.Errorf("can not get cft version form \".cft\", current project doesn't belong to crafter framework")
	}

	*manifest = *m
	_, err = gv.NewVersion(manifest.Version)
	if err != nil {
		return fmt.Errorf("invalid cft version in \".cft\", err: %v", err)
	}

	return nil
}

const cftTitle = "// Code generated by cft. DO NOT EDIT."

func (manifest *Manifest) String() string {
	conf, _ := yaml.Marshal(*manifest)

	return cftTitle + "\n\n" +
		string(conf)
}

func (manifest *Manifest) Persist(dir string) error {
	file := filepath.Join(dir, ManifestFile)
	fd, err := os.OpenFile(file, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, os.FileMode(0o644))
	if err != nil {
		return err
	}
	defer fd.Close()
	_, err = fd.WriteString(manifest.String())
	return err
}

// loadConfigFile load config file from path
func loadConfigFile(path string) (*Manifest, error) {
	file, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	var manifest Manifest
	file = bytes.TrimPrefix(file, []byte(cftTitle))
	if err = yaml.Unmarshal(file, &manifest); err != nil {
		return nil, fmt.Errorf("decode \".cft\" failed, err: %v", err)
	}
	return &manifest, nil
}

type GeneratedJSON struct {
	ServiceGroup string   `json:"serviceGroup"`
	Module       string   `json:"module"`
	Clients      []string `json:"clients"`
}

func LoadGeneratedJson(filename string, generatedJson *GeneratedJSON) (*GeneratedJSON, error) {
	// Check if the file exists
	_, err := os.Stat(filename)
	if os.IsNotExist(err) {
		// File does not exist, create it
		file, err := os.Create(filename)
		if err != nil {
			return nil, err
		}
		defer file.Close()
		err = writeJsonToFile(filename, generatedJson)
		if err != nil {
			return nil, err
		}
		return generatedJson, nil
	}
	original, err := readJsonFromFile(filename)
	if err != nil {
		return nil, err
	}
	merged := merge(original, generatedJson)
	err = writeJsonToFile(filename, merged)
	if err != nil {
		return nil, err
	}

	return merged, nil
}

func writeJsonToFile(filename string, data *GeneratedJSON) error {
	prettyJson, err := json.MarshalIndent(data, "", "    ")
	if err != nil {
		return err
	}
	return os.WriteFile(filename, prettyJson, 0644)
}

func readJsonFromFile(filename string) (*GeneratedJSON, error) {
	// Open the file in append mode
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}
	var original *GeneratedJSON
	err = json.Unmarshal(data, &original)
	if err != nil {
		return nil, err
	}

	return original, nil
}

func merge(original, generated *GeneratedJSON) *GeneratedJSON {
	indexFn := func(list []string) map[string]string {
		listMap := make(map[string]string)
		for _, item := range list {
			listMap[item] = item
		}
		return listMap
	}

	indexed := indexFn(original.Clients)
	for _, client := range generated.Clients {
		if _, ok := indexed[client]; !ok {
			original.Clients = append(original.Clients, client)
		}
	}

	return original
}
